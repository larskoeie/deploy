#!/bin/sh
#
# - Command 'diff' uses rsync with --delete, real transfer commands do not ! So nothing will ever be deleted.
#

#
# Reads state variables. 
# Reads config file (.deploy.cnf) and apply values to global variables for later use.
#
read_config () {
  if [ -f .deploy.cnf ]; then
    mv .deploy.cnf .deploy/config
  fi
  if [ -f .deploy.state ]; then
    mv .deploy.state .deploy/state
  fi

  REMOTEINDEX=""
  if [ -f .deploy/state ]; then
    f=`cat .deploy/state | cut -d = -f 1`
    v=`cat .deploy/state | cut -d = -f 2`
    if [ "$f" = "remote" ]; then
      REMOTEINDEX=$v
    fi
  fi
  if [ -f .deploy/config ]
  then
    while read p; do
      f=`echo $p | cut -d = -f 1`
      r=`echo $f | cut -d . -f 1`
      field=`echo $f | cut -d . -f 2`
      value=`echo $p | cut -d = -f 2`

      if [ "$r" = "local" ];
      then
        case $field in
          "dbhost" ) LOCALDBHOST=$value ;;
          "dbuser" ) LOCALDBUSER=$value ;;
          "db" ) LOCALDB=$value ;;
        esac
      else
        if [ ! -n "$REMOTEINDEX" ]; then
          REMOTEINDEX=$r
          write_state
          echo "Remote not set. Switched to $REMOTEINDEX"
        fi
      fi
      if [ "$r" = "$REMOTEINDEX" ];
      then
        case $field in
          "type" ) REMOTETYPE=$value ;;
          "title" ) REMOTETITLE=$value ;;
          "host" ) REMOTEHOST=$value ;;
          "user" ) REMOTEUSER=$value ;;
          "root" ) REMOTEROOT=$value ;;
          "httpfolder" ) REMOTEHTTPFOLDER=$value ;;
          "dbhost" ) REMOTEDBHOST=$value ;;
          "dbuser" ) REMOTEDBUSER=$value ;;
          "db" ) REMOTEDB=$value ;;
          "dbdump" ) REMOTEDBDUMP=$value ;;
          "url" ) REMOTEURL=$value ;;
        esac
      fi
    done < .deploy/config
  fi
}

#
# Write state variables to file.
#
write_state () {
  echo "remote=$REMOTEINDEX" > .deploy/state
}

#
# Shows a prompt, waits for response and returns
#
deploy_confirm () {
	echo -n "$1 (y/n)"
	read -r c
	if [ "$c" != "y" ]
	then
	  exit;
	fi
}

#
# Shows a prompt, waits for response and exits if negative
#
deploy_confirm_or_exit () {
	echo -n "$1 Continue ? (y/n)"
	read -r c
	if [ "$c" != "y" ]
	then
	  echo "Aborted";
	  exit;
	fi
}

deploy_log () {
  t=`date +"%Y.%m.%d %H.%M.%S"`
  echo "$t - $1" >> $LOCALROOT/.deploy/log
}

#
# Require that the current directory is the one above http/
#
require_site_root () {
  if [ ! -d "http" ]; then echo "Not site root."; exit 1;
  fi
}

#
# Make sure that configuration for remote site exists. This is required for most commands.
#
require_remote () {
  if [ ! $REMOTEROOT ]
  then
    echo "Missing remote root"; exit;
  fi
  case $REMOTETYPE in
    "local" )
      if [ $LOCALROOT$LOCALHTTPFOLDER = $REMOTEROOT$REMOTEHTTPFOLDER ]; then echo "Remote site is same as local."; exit;
      fi
    ;;
    "ssh" )
      if [ ! $REMOTEHOST ]; then echo "Missing remote host"; exit;
      fi
      if [ ! $REMOTEUSER ]; then echo "Missing remote user"; exit;
      fi
    ;;
    "ftp" )
      if [ ! $REMOTEHOST ]; then echo "Missing remote host"; exit;
      fi
      if [ ! $REMOTEUSER ]; then echo "Missing remote user"; exit;
      fi
    ;;
  esac
}

#
# Make sure that SSH connection to remote exists.
#
require_ssh () {
  if [ $REMOTETYPE != "ssh" ]; then
    echo "SSH mode only."
    exit 1;
  fi
}

#
# Make sure that configuration for the local DB exists.
#
require_localdb () {
  if [ -z $LOCALDB ]; then echo "No local DB configured."; exit 1;
  fi
}

#
# Make sure that configuration for a remote DB exists.
#
require_remotedb () {
 if [ ! -n "$REMOTEDB" ]; then echo "No remote DB configured."; exit 1;
 fi
}

#
# Dump remote DB to file and download the file.
#
remote_dumpdb () {
  require_ssh
  require_remotedb
  DUMPPATH=".deploy/dump/$REMOTEINDEX/"
  deploy_log "Dumping $REMOTEDB on $REMOTEDBUSER@$REMOTEDBHOST ..."
  ssh $REMOTEUSER@$REMOTEHOST "mysqldump --skip-extended-insert -h $REMOTEDBHOST -u $REMOTEDBUSER -p $REMOTEDB > /tmp/temp.sql"
  deploy_log "Downloading dump ..."
  scp $REMOTEUSER@$REMOTEHOST:/tmp/temp.sql $DUMPPATH
}

#
# Downloads db dump from current remote and places file(s) in .deploy/dump. Handles any untar'ing/unzipping that is neccessary.
# The downloaded dump is not created by this script.
#
remote_downloaddbdump () {
  deploy_log "Downloading db dump ..."
  DUMPPATH=".deploy/dump/$REMOTEINDEX/"
  mkdir -p $DUMPPATH
  case $REMOTETYPE in 
    "ssh" )
      scp -r $REMOTEUSER@$REMOTEHOST:$REMOTEDBDUMP $DUMPPATH
    ;;
    "ftp" )
      if [ -z $REMOTEDBDUMP ]; then
        exit;
      fi
      
      require_remotepw
      cd .deploy/dump/$REMOTEINDEX
      wget -r -nH -nv ftp://$REMOTEUSER:$REMOTEPASSWORD@$REMOTEHOST//$REMOTEROOT$REMOTEDBDUMP
      cd ../../..

    ;;
  esac
  
  cd $DUMPPATH
  for f in `ls *.gz`; do
    gunzip -f $f
  done

  cd $LOCALROOT
  deploy_log "Done"
}

#
# Dump local DB to file.
#
local_dumpdb () {
  require_localdb
  DUMPPATH="local.sql"
  deploy_log "Dumping $LOCALDB on $LOCALDBUSER@$LOCALDBHOST ..."
  mysqldump --skip-extended-insert $ignoretables -h $LOCALDBHOST -u $LOCALDBUSER -p$LOCALDBPASSWORD $LOCALDB > $DUMPPATH
  deploy_log "Done."
}

#
# Import dump from remote site to local DB
# Dump(s) are fetched from ./deploy/dump/[remote_key]/*
# Dump(s) should be plain sql format. File extensions are ignored. DROP/CREATE/TRUNCATE on tables etc. are optional.
#
local_importremotedb () {
  require_localdb

  deploy_log "Importing database dump ...";
  
  DUMPPATH=".deploy/dump/$REMOTEINDEX/"
  for f in `ls $DUMPPATH`; do
    echo "File -> $f"
    echo "Importing file $f ..."
    # remove "create database" and "use" as we want to control database name from outside
    # there is a (at least theoretical) risc that this can remove something that is not a sql "CREATE DATABASE" or "USE" statement.
    sed -i.bak "s/^CREATE DATABASE.*$//g;s/^USE.*$//g" $DUMPPATH$f
    mysql -v -h $LOCALDBHOST -u $LOCALDBUSER -p$LOCALDBPASSWORD $LOCALDB < $DUMPPATH$f
  done
  
  deploy_log "Done.";

}

#
# Execute SQL query on local DB.
#
local_sqlq () {	
  mysql -h $LOCALDBHOST -u $LOCALDBUSER -p$LOCALDBPASSWORD $LOCALDB -e "$1"
}

# 
# Executes SQL query on DB.
#
sqlq () {
	# for now, pass query on to local DB
	local_sqlq "$1"
}

# Absolute path to this script
SCRIPT=$(readlink -f $0)
# Absolute path this script is in
SCRIPTPATH=`dirname $SCRIPT`
# The current working directory
LOCALROOT=`pwd`

# apply sane config default values
LOCALHTTPFOLDER="http/"
REMOTEHTTPFOLDER="http/"
REMOTEINDEX=""
REMOTETYPE="ssh" # "local", "ssh" or "ftp"
REMOTETITLE=""
LOCALSITENAME=`basename $LOCALROOT`
TIME=`date +"%y%m%d"`
DIFFCOLORSED='s/^-/\x1b[41m-/;s/^+/\x1b[44m+/;s/$/\x1b[0m/'
RSYNCCOLORSED="s/<f/\x1b[44m&/g;s/>f/\x1b[44m&/g;s/$/\x1b[0m/g"
INCLUDEFROM=""
EXCLUDEFROM="--exclude-from $SCRIPTPATH/deploy-exclude.txt"
mkdir -p .deploy

# Make path and folder names sane. Make sure that dirs have trailing slashes and files haven't.
if [ -n "$2" ]; then
	# remove trailing slashes from all vars
	REMOTEROOT=`echo $REMOTEROOT | sed "s/\/*$//g"` 
	LOCALHTTPFOLDER=`echo $LOCALHTTPFOLDER | sed "s/\/*$//g"` 
	REMOTEHTTPFOLDER=`echo $REMOTEHTTPFOLDER | sed "s/\/*$//g"` 

	# make paths
	LOCALPATH=$2
	REMOTEPATH=`echo "$LOCALPATH" | sed "s/^$LOCALHTTPFOLDER/$REMOTEHTTPFOLDER/g"`  

	LOCALPATH=`echo $LOCALPATH | sed "s/\/*$//g"`
	REMOTEPATH=`echo $REMOTEPATH | sed "s/^\/*//g;s/\/*$//g"`

	# add trailing slashes
	LOCALROOT="$LOCALROOT/"
  if [ ! -z "$REMOTEROOT" ]; then
    REMOTEROOT="$REMOTEROOT/"
  fi
	LOCALHTTPFOLDER="$LOCALHTTPFOLDER/"
	if [ ! -z "$REMOTEHTTPFOLDER" ]; then
    REMOTEHTTPFOLDER="$REMOTEHTTPFOLDER/"
  fi

  # if path on local is a directory, add trailing slash, on local AND on remote
  if [ -d "$LOCALPATH" ]; then
    LOCALPATH="$LOCALPATH/"
    if [ ! -z "$REMOTEPATH" ]; then
      REMOTEPATH="$REMOTEPATH/"
    fi
  fi

  if [ "$REMOTETYPE" = "local" ] && [ "$LOCALROOT$LOCALPATH" = "$REMOTEROOT$REMOTEPATH" ]; then
    echo "Local and remote site are in the same place."
    exit
  fi
fi

USAGE="Usage: deploy <command> [path]
  General commands :
    config       Output current configuration.
    diff         Show files and folders in specified path on local that are not on remote or have different size or timestamp
    diffdb       Not on FTP mode.
    down         Download the specified path from remote to local
    downdb       Dump remote db to file, download file and import into local db.
    dumplocaldb  Dump the local db to local file
    dumpremotedb Dump the remote db to local file. Not on FTP mode.
    up           Upload the specified path from local to remote
    remote       Switch remote.";


# If no command, show usage
if [ ! -n "$1" ]; then echo "$USAGE"; exit 1;
fi

require_site_root
read_config

#
# Source system specific scripts.
#
. $SCRIPTPATH/deploy-typo3
. $SCRIPTPATH/deploy-drupal7


#
# Reads a password from prompt. Show *'s
#
read_pw () {
  unset pw
  while IFS=`read -s -p "Enter :$prompt" -r char`
  do
    if [ "$char" = $'\0' ]
    then
      break
    fi
    prompt='*'
    pw="$pw$char"
  done
  echo
  return $pw
}


require_remotepw () {
  unset REMOTEPASSWORD
  prompt="FTP password for $REMOTEUSER@$REMOTEHOST : "
  read -p "$prompt" -r REMOTEPASSWORD
  echo
 	mkdir -p .deploy/remote/$REMOTEINDEX
}

#
# Uploads the object at $1 traversing recursively creating dirs on the go.
#
deploy_ftp_up () {
  if [ -d $1 ]; then
    echo "mkdir $1" >> $LOCALROOT/.deploy/ftp-temp.txt
    for f in `ls $1`; do
      deploy_ftp_up $1/$f
    done
  fi
  if [ -f $1 ]; then
    echo "put $1" >> $LOCALROOT/.deploy/ftp-temp.txt
  fi
}


strstr () {
	case "$1" in 
	  *$2* )
	    return 1;
	  ;;
	  * )
	    return 0;	
	  ;;
	esac
}


# add site specific include and exclude file
if [ -f .deploy/include.txt ]; then
  INCLUDEFROM="$INCLUDEFROM --include-from .deploy/include.txt"
fi
if [ -f .deploy/exclude.txt ]; then
  EXCLUDEFROM="$EXCLUDEFROM --exclude-from .deploy/exclude.txt"
fi

# write remote title to stdout
if [ -n "$REMOTETITLE" ] && [ "$1" != "remote" ]; then
  echo "On remote $REMOTETITLE"
fi

if [ $handled ]; then
  exit 0;
fi

CMD=$1
COMMAND=$CMD

#
# Invoke "before"-hooks, executing more specific hooks before more general
#
STOP_PROPAGATION=0
if [ -f ".deploy/hooks/pre-$CMD-$REMOTEINDEX" ]; then
  . ".deploy/hooks/pre-$CMD-$REMOTEINDEX"
fi
if [ ! $STOP_PROPAGATION ] && [ -f ".deploy/hooks/pre-$CMD" ]; then
  . ".deploy/hooks/pre-$CMD"
fi

#
# Invoke "instead"-hook
#
STOP_PROPAGATION=0
if [ -f ".deploy/hooks/$CMD-$REMOTEINDEX" ]; then
  . ".deploy/hooks/$CMD-$REMOTEINDEX"
  COMMAND="_replaced"
fi
if [ ! $STOP_PROPAGATION ] && [ -f ".deploy/hooks/$CMD" ]; then
  . .deploy/hooks/$CMD
  COMMAND="_replaced"
fi

#
# Now go to action
#
case "$COMMAND" in
  "remote" )
    if [ ! -n "$2" ]; then
      echo "Usage: deploy remote <remote>";
   
	    if [ -f .deploy/config ]
	    then
	      rs=",local,"
	      while read p; do
	        f=`echo $p | cut -d = -f 1`
	        r=`echo $f | cut -d . -f 1`
	        if [ ! -z $r ]; then
	          strstr $rs ",$r,"
            if [ $? -eq 0 ]; then
              if [ "$r" = "$REMOTEINDEX" ]; then
  	            echo "* $r"
	            else
	              echo "  $r"
   	          fi
	   	        rs="$rs,$r,"
  	        fi
  	      fi
 	        
	      done < .deploy/config
	    fi
    else
      REMOTEINDEX=$2
      write_state
      read_config
      echo "Switched to remote $REMOTETITLE"
    fi
    ;;
 
  "config" )
    echo "Remote host      : $REMOTEHOST"
    echo "Remote user      : $REMOTEUSER"
    echo "Remote root      : $REMOTEROOT"
    echo "Local DB host    : $LOCALDBHOST"
    echo "Local DB user    : $LOCALDBUSER"
    if [ -z $LOCALDBPASSWORD ]; then
      echo "Local DB pw      : unknown";
    else
      echo "Local DB pw      : OK";
    fi
    echo "Local DB         : $LOCALDB"
    echo "Remote DB host   : $REMOTEDBHOST"
    echo "Remote DB user   : $REMOTEDBUSER"
    if [ -z $REMOTEDBPASSWORD ]; then
      echo "Remote DB pw     : unknown";
    else
      echo "Remote DB pw     : OK";
    fi
    echo "Remote DB        : $REMOTEDB"    
    echo "Remote DB backup : $REMOTEDBDUMP"
    
    if [ "ssh" = "$REMOTETYPE" ]; then
      echo -n "Local PHP        : "
      php --version | sed -n 1p
      echo -n "Remote PHP       : "
      ssh $REMOTEUSER@$REMOTEHOST "php --version | sed -n 1p"
    fi
    ;;
 
  #
  # Will make a rsync dry-run or a diff depending on type of localpath.
  #
  "diff" )
    if [ ! -n "$LOCALPATH" ]; then echo "Usage: deploy diff <path>"; exit 1; 
    fi

    if [ -f $LOCALPATH ]; then echo -n "Local file  : "; ls -l $LOCALPATH
    fi

    echo "Blue lines are local - red are remote"
    
    case "$REMOTETYPE" in
      "local" )
        if [ -f $LOCALPATH ] && [ -f $REMOTEROOT$REMOTEPATH ]
        then          
          echo -n "Remote file : "
          ls -l $REMOTEROOT$REMOTEPATH
          diff -w -u $REMOTEROOT$REMOTEPATH $LOCALPATH | sed $DIFFCOLORSED
        else
          rsync -avnci $INCLUDEFROM $EXCLUDEFROM $LOCALPATH $REMOTEROOT$REMOTEPATH | grep ">f" | sed $RSYNCCOLORSED
        fi

      ;;
      "ssh" )
        if [ -f $LOCALPATH ]
        then
          echo -n "Remote file : "
          ssh $REMOTEUSER@$REMOTEHOST "cd $REMOTEROOT; ls -l $REMOTEPATH"
 
          # do an actual diff on two files
          ssh $REMOTEUSER@$REMOTEHOST "cat $REMOTEROOT$REMOTEPATH" | diff -w -u - "$LOCALPATH" | sed $DIFFCOLORSED
        fi
        if [ -d $LOCALPATH ]
        then
          # diff folder structure using rsync dry-run
          rsync -avnci --delete $INCLUDEFROM $EXCLUDEFROM ${2%/}/ $REMOTEUSER@$REMOTEHOST:$REMOTEROOT$REMOTEPATH | sed $RSYNCCOLORSED
        fi
      ;;

      "ftp" )
        require_remotepw
        deploy_log "Syncing local cache from remote ..."
        cd .deploy/remote/$REMOTEINDEX
        wget -r -nH -nv ftp://$REMOTEUSER:$REMOTEPASSWORD@$REMOTEHOST//$REMOTEROOT$REMOTEPATH
        cd ../../..
	deploy_log "Done."
        if [ -f $LOCALPATH ]
        then
          # do an actual diff on two files
          diff -w -u .deploy/remote/$REMOTEINDEX/$REMOTEROOT$REMOTEPATH $LOCALPATH | sed $DIFFCOLORSED
        fi
        if [ -d $LOCALPATH ]
        then
          # diff structures using rsync
          echo "-avnci --delete $LOCALPATH .deploy/remote/$REMOTEINDEX/$REMOTEROOT$REMOTEPATH | sed $RSYNCCOLORSED"
          rsync -avnci --delete $INCLUDEFROM $EXCLUDEFROM $LOCALPATH .deploy/remote/$REMOTEINDEX/$REMOTEROOT$REMOTEPATH | sed $RSYNCCOLORSED

        fi

      ;;
    esac
    ;;

  "diffdb" )
    # do a diff on the two db-dump files
    LOCAL="local.sql"
    REMOTE="$REMOTEINDEX.sql"

    if [ ! -f $LOCAL ]
      then echo "no local dump - use dumplocaldb"; exit;
    fi
    if [ ! -f $REMOTE ]
      then echo "no remote dump - use dumpremotedb"; exit;
    fi

    diff $LOCAL $REMOTE | sed $DIFFCOLORSED
  ;;
 
  # diff and grep for text within diff result
  # TODO : remotetype ftp not implemented 
  "diffsearch" )
    if [ ! -n "$3" ]; then echo "Usage: deploy diffsearch <path> <string>"; exit 1;
    fi

    echo "Diffing '$LOCALPATH' and searching for '$3' ...";
    echo "Blue lines are added on local - red are removed"

    case "$REMOTETYPE" in 
      "local" )
        if [ -f $LOCALPATH ]; then
          diff -w -u $REMOTEROOT$REMOTEPATH $LOCALPATH | grep $3 | sed $DIFFCOLORSED
        fi
        if [ -d $LOCALPATH ]; then
          rsync -avnc $INCLUDEFROM $EXCLUDEFROM $LOCALPATH $REMOTEROOT$REMOTEPATH | grep $3 | sed $RSYNCCOLORSED
        fi
      ;;
      
      "ssh" )
        if [ -f $LOCALPATH ]; then
          ssh $REMOTEUSER@$REMOTEHOST "cat $REMOTEROOT$REMOTEPATH" | diff -w -u - "$LOCALPATH" | grep $3 | sed $DIFFCOLORSED
        fi
        if [ -d $LOCALPATH ]; then
          rsync -avnc $INCLUDEFROM $EXCLUDEFROM ${2%/}/ $REMOTEUSER@$REMOTEHOST:$REMOTEROOT$REMOTEPATH | grep $3 | sed $RSYNCCOLORSED
        fi
      ;;
      
      "ftp" )
      ;;
    esac  
  ;;
  "down" )
    if [ ! -n "$LOCALPATH" ]; then echo "Usage: deploy down <path>"; exit 1;
    fi

    # check if "http/" is owned by the current user. If not, downloading files will probably cause trouble. Confirm.
    HTTPOWNER=$(stat -c %U http)
    if [ $HTTPOWNER != $(id -u -n) ]; then
      echo "You are not $HTTPOWNER. Continue? y/n";
      prompt=""
      read -p "$prompt" -r -s -n 1 char
      if [[ $char != "y" ]]
      then
        echo;
        exit;
      fi

    fi

    deploy_log "Downloading $LOCALPATH ...";
    case "$REMOTETYPE" in
      "local" )
        rsync -avci $INCLUDEFROM $EXCLUDEFROM $REMOTEROOT$REMOTEPATH $LOCALPATH | sed $RSYNCCOLORSED        
      ;;
      "ssh" )
        # download structure or single file using rsync
        rsync -avi $INCLUDEFROM $EXCLUDEFROM $REMOTEUSER@$REMOTEHOST:$REMOTEROOT$REMOTEPATH $LOCALPATH
        ;;
      "ftp" )
        require_remotepw
        cd .deploy/remote/$REMOTEINDEX 
        wget -r -nH ftp://$REMOTEUSER:$REMOTEPASSWORD@$REMOTEHOST//$REMOTEPATH
        cd ../../..
        rsync -avi $INCLUDEFROM $EXCLUDEFROM .deploy/remote/$REMOTEINDEX/$REMOTEROOT$REMOTEPATH $LOCALPATH
        ;;
    esac
    deploy_log "Done.";

    ;;

  
  #
  # Would probably not be called directly in real life, as it is part of "downdb"
  #
  "downdbdump" )
    remote_downloaddbdump
    ;;
  
  #
  # Copy remote database to local.
  #
  "downdb" )
    # if a dump path is defined, use it - otherwise, make a dump
    if [ -n $REMOTEDBDUMP ]; then
      remote_downloaddbdump
    else      
      remote_dumpdb
    fi
    
    local_importremotedb
    ;;
   
    
  "dumplocaldb" )
    # this dump is specifically with diff in mind
    if [ ! -n "$LOCALDB" ]; then echo "Missing localdb - check .deploy.cnf"; exit 1;
    fi
    DUMPPATH=".deploy/dump/local.sql"
    echo "Dumping to $DUMPPATH ..."
    # --skip-extended-insert makes dump larger, but provides better results with diff later on
    mysqldump --skip-extended-insert $ignoretables -h $LOCALDBHOST -u $LOCALDBUSER -p $LOCALDB > $DUMPPATH
    ;;

  # 
  "dumpremotedb" )
    remote_dumpdb
    ;;

  # run a sql query on local db
  "sqlq" )
    if [ ! -n "$2" ]; then echo "Usage: deploy sqlq <sql>"; exit 1;
    fi
    sqlq "$2"
    ;;
    
  "up" )
    if [ ! -n "$LOCALPATH" ]; then echo "Usage: deploy up <path>"; exit 1; 
    fi
    deploy_confirm_or_exit "This will upload $LOCALPATH to $REMOTEINDEX : $REMOTETITLE.";
    deploy_log "Uploading $LOCALPATH ...";
    case $REMOTETYPE in 
      "local" )
        rsync -avci $INCLUDEFROM $EXCLUDEFROM $LOCALPATH $REMOTEROOT$REMOTEPATH | sed $RSYNCCOLORSED
      ;;
      "ssh" )
        rsync -avci $INCLUDEFROM $EXCLUDEFROM $LOCALPATH $REMOTEUSER@$REMOTEHOST:$REMOTEROOT$REMOTEPATH
      ;;
      "ftp" )
        require_remotepw
        rsync -avci $INCLUDEFROM $EXCLUDEFROM $LOCALPATH .deploy/remote/$REMOTEINDEX/$REMOTEROOT$REMOTEPATH
        
        echo  "
open $REMOTEHOST
user $REMOTEUSER $REMOTEPASSWORD
" > $LOCALROOT/.deploy/ftp-temp.txt
        cd .deploy/remote/$REMOTEINDEX

        deploy_ftp_up $REMOTEPATH
        ftp -nvp < $LOCALROOT/.deploy/ftp-temp.txt
#        rm $LOCALROOT/.deploy/ftp-temp.txt
      ;;
    esac
    deploy_log "Done."
    ;;
		
  # create tar with folder
  "dumplocal" )
    if [ ! -n "$LOCALPATH" ]; then echo "Usage: deploy dumplocal <path>"; exit 1;
    fi

    DUMPPATH=`echo $LOCALSITENAME-local-$LOCALPATH | sed 's/\//-/g'`
    echo $DUMPPATH

    tar -cvfz $DUMPPATH.tar.gz $LOCALPATH
    ;;

  "importlocaldb" )
    require_localdb
    if [ -z $2 ]; then
      echo "Usage: deploy importlocaldb <file>"
      exit 1;
    fi
    deploy_log "Importing database to local ..."
    mysql -h$LOCALDBHOST -u$LOCALDBUSER -p$LOCALDBPASSWORD $LOCALDB < $2
    deploy_log "Done."
    ;;
    
  #
  # Do "ls -l" on the remote site.
  #
  "ls" )
    if [ ! -n "$LOCALPATH" ]; then echo "Usage: deploy ls <path>"; exit 1; 
    fi
    case $REMOTETYPE in 
      "local" )
        ls -l $REMOTEROOT$REMOTEPATH
      ;;
      "ssh" )    
        ssh $REMOTEUSER@$REMOTEHOST "ls -l $REMOTEROOT$REMOTEPATH"
      ;;
      "ftp" )
        # TODO
      ;;
    esac
	;;
	
	"mkdir" )
	  if [ ! -n "$LOCALPATH" ]; then echo "Usage: deploy $1 <path>"; exit 1; 
    fi
    case $REMOTETYPE in 
      "local" )
        mkdir -p $REMOTEROOT$REMOTEPATH
      ;;
      "ssh" )    
        ssh $REMOTEUSER@$REMOTEHOST "mkdir -p $REMOTEROOT$REMOTEPATH"
      ;;
      "ftp" )
        # TODO
      ;;
    esac
  
	;;
  
  "_replaced" )
  ;;

  "log" )
    tail .deploy/log
  ;;
esac

if [ -f .deploy/temp.sql ]; then rm .deploy/temp.sql;
fi

#
# Source system specific scripts.
#
#. $SCRIPTPATH/deploy-typo3
#. $SCRIPTPATH/deploy-drupal7


#
# Invoke "after"-hooks
#
if [ -f ".deploy/hooks/post-$CMD-$REMOTEINDEX" ]; then
  . ".deploy/hooks/post-$CMD-$REMOTEINDEX"
fi
if [ -f ".deploy/hooks/post-$CMD" ]; then
  . ".deploy/hooks/post-$CMD"
fi



